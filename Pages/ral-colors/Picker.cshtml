@page "/ral-colors/picker"
@using Microsoft.AspNetCore.Mvc.Localization
@using System.Globalization
@model protabula_com.Pages.ral_colors.PickerModel
@inject IViewLocalizer Localizer
@{
    var culture = CultureInfo.CurrentUICulture.Name;
    ViewData["Title"] = Localizer["Title"].Value;
    ViewData["MetaDescription"] = Localizer["MetaDescription"].Value;

    ViewData["Breadcrumbs"] = new List<(string, string?, object?)>
    {
        (Localizer["BreadcrumbColors"].Value, "/ral-colors/Index", new Dictionary<string, string> { ["culture"] = culture }),
        (Localizer["BreadcrumbPicker"].Value, null, null)
    };

    var request = ViewContext.HttpContext.Request;
    var baseUrl = $"{request.Scheme}://{request.Host}";
}

@section Head {
    <script type="application/ld+json">
    {
        "@@context": "https://schema.org",
        "@@type": "WebApplication",
        "name": "@Localizer["Title"].Value",
        "description": "@Localizer["MetaDescription"].Value",
        "url": "@baseUrl/@culture/ral-colors/picker",
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Any",
        "offers": {
            "@@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>
}

<h1>@ViewData["Title"]</h1>
<p class="text-secondary intro-text">@Localizer["Intro"]</p>

<div class="picker-container">
    <!-- Upload Zone -->
    <div class="upload-zone" id="uploadZone">
        <div class="upload-content">
            <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <p class="upload-hint">@Localizer["UploadHint"]</p>
            <span class="upload-button" id="uploadButton">@Localizer["UploadButton"]</span>
        </div>
    </div>
    <input type="file" id="imageInput" accept="image/*" hidden />

    <!-- Canvas Container (hidden until image loaded) -->
    <div class="canvas-container" id="canvasContainer" style="display: none;">
        <div class="canvas-viewport">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="pickerCanvas"></canvas>
                <div class="sample-indicator" id="sampleIndicator">
                    <span class="crosshair-h"></span>
                    <span class="crosshair-v"></span>
                </div>
            </div>

            <!-- Floating hint overlay -->
            <div class="canvas-hint-overlay">
                <p class="canvas-hint" id="canvasHint">@Localizer["ClickToSample"]</p>
            </div>

            <!-- Unified floating toolbar -->
            <div class="canvas-toolbar">
                <div class="toolbar-group">
                    <button type="button" class="toolbar-btn" id="removeImage" title="@Localizer["RemoveImage"]">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14"/>
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                        </svg>
                        <span class="toolbar-label">Change</span>
                    </button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group toolbar-zoom">
                    <button type="button" class="toolbar-btn toolbar-btn-icon" id="zoomOut" title="Zoom out">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="11" cy="11" r="8"/>
                            <path d="M21 21l-4.35-4.35M8 11h6"/>
                        </svg>
                    </button>

                    <div class="zoom-display">
                        <span class="zoom-level" id="zoomLevel">100%</span>
                    </div>

                    <button type="button" class="toolbar-btn toolbar-btn-icon" id="zoomIn" title="Zoom in">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="11" cy="11" r="8"/>
                            <path d="M21 21l-4.35-4.35M11 8v6M8 11h6"/>
                        </svg>
                    </button>

                    <button type="button" class="toolbar-btn toolbar-btn-icon" id="zoomReset" title="Fit to view">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Section (hidden until color sampled) -->
    <div class="results-section" id="resultsSection" style="display: none;">
        <!-- Sampled Color -->
        <div class="sampled-color-card">
            <h2 class="section-title">@Localizer["SampledColor"]</h2>
            <div class="sampled-color">
                <div class="sampled-swatch" id="sampledSwatch"></div>
                <div class="sampled-info">
                    <code class="sampled-hex" id="sampledHex"></code>
                    <span class="sampled-rgb" id="sampledRgb"></span>
                </div>
            </div>
        </div>

        <!-- Loading State -->
        <div class="loading-state" id="loadingState" style="display: none;">
            <div class="loading-spinner"></div>
            <span>@Localizer["Loading"]</span>
        </div>

        <!-- Matches -->
        <div class="matches-section" id="matchesSection" style="display: none;">
            <div class="matches-category">
                <h2 class="section-title">RAL Classic</h2>
                <div class="matches-list" id="classicMatchesGrid"></div>
            </div>
            <div class="matches-category">
                <h2 class="section-title">RAL Design System Plus</h2>
                <div class="matches-list" id="designMatchesGrid"></div>
            </div>
        </div>
    </div>
</div>

<!-- Legend and Algorithm Explanation (always visible for SEO) -->
<section class="info-section">
    <h2>@Localizer["LegendTitle"]</h2>
    <p class="info-intro">@Localizer["LegendIntro"]</p>

    <div class="legend-table-wrapper">
        <table class="legend-table">
            <thead>
                <tr>
                    <th>@Localizer["LegendLabel"]</th>
                    <th>@Localizer["LegendDeltaE"]</th>
                    <th>@Localizer["LegendMeaning"]</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><span class="legend-badge exact">@Localizer["MatchExact"]</span></td>
                    <td class="legend-range">&lt; 1.0</td>
                    <td>@Localizer["LegendExactDesc"]</td>
                </tr>
                <tr>
                    <td><span class="legend-badge very-close">@Localizer["MatchVeryClose"]</span></td>
                    <td class="legend-range">1.0 – 2.0</td>
                    <td>@Localizer["LegendVeryCloseDesc"]</td>
                </tr>
                <tr>
                    <td><span class="legend-badge close">@Localizer["MatchClose"]</span></td>
                    <td class="legend-range">2.0 – 5.0</td>
                    <td>@Localizer["LegendCloseDesc"]</td>
                </tr>
                <tr>
                    <td><span class="legend-badge similar">@Localizer["MatchSimilar"]</span></td>
                    <td class="legend-range">5.0 – 10.0</td>
                    <td>@Localizer["LegendSimilarDesc"]</td>
                </tr>
                <tr>
                    <td><span class="legend-badge different">@Localizer["MatchDifferent"]</span></td>
                    <td class="legend-range">&gt; 10.0</td>
                    <td>@Localizer["LegendDifferentDesc"]</td>
                </tr>
            </tbody>
        </table>
    </div>
</section>

<section class="info-section">
    <h2>@Localizer["AlgorithmTitle"]</h2>
    <p>@Localizer["AlgorithmIntro"]</p>

    <h3>@Localizer["AlgorithmStepsTitle"]</h3>
    <ol class="algorithm-steps">
        <li>@Localizer["AlgorithmStep1"]</li>
        <li>@Localizer["AlgorithmStep2"]</li>
        <li>@Localizer["AlgorithmStep3"]</li>
        <li>@Localizer["AlgorithmStep4"]</li>
    </ol>

    <h3>@Localizer["AlgorithmCIEDE2000Title"]</h3>
    <p>@Localizer["AlgorithmCIEDE2000Desc"]</p>

    <h3>@Localizer["AlgorithmLabTitle"]</h3>
    <p>@Localizer["AlgorithmLabDesc"]</p>
</section>

@section Scripts {
    <script>
        (function() {
            const culture = '@culture';
            const uploadZone = document.getElementById('uploadZone');
            const imageInput = document.getElementById('imageInput');
            const canvasContainer = document.getElementById('canvasContainer');
            const canvasWrapper = document.getElementById('canvasWrapper');
            const canvas = document.getElementById('pickerCanvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const sampleIndicator = document.getElementById('sampleIndicator');
            const canvasHint = document.getElementById('canvasHint');
            const removeImageBtn = document.getElementById('removeImage');
            const resultsSection = document.getElementById('resultsSection');
            const sampledSwatch = document.getElementById('sampledSwatch');
            const sampledHex = document.getElementById('sampledHex');
            const sampledRgb = document.getElementById('sampledRgb');
            const loadingState = document.getElementById('loadingState');
            const matchesSection = document.getElementById('matchesSection');
            const classicMatchesGrid = document.getElementById('classicMatchesGrid');
            const designMatchesGrid = document.getElementById('designMatchesGrid');
            const zoomInBtn = document.getElementById('zoomIn');
            const zoomOutBtn = document.getElementById('zoomOut');
            const zoomResetBtn = document.getElementById('zoomReset');
            const zoomLevelDisplay = document.getElementById('zoomLevel');

            let currentImage = null;
            let baseScale = 1; // Scale to fit image in container
            let zoom = 1; // Additional zoom factor
            let panX = 0, panY = 0; // Pan offset in image coordinates
            let isPanning = false;
            let lastPanX = 0, lastPanY = 0;
            let lastPinchDist = 0;

            const MIN_ZOOM = 1;
            const MAX_ZOOM = 8;

            // Localized strings
            const strings = {
                viewDetails: '@Localizer["ViewDetails"].Value',
                sampleAgain: '@Localizer["SampleAgain"].Value',
                matchExact: '@Localizer["MatchExact"].Value',
                matchVeryClose: '@Localizer["MatchVeryClose"].Value',
                matchClose: '@Localizer["MatchClose"].Value',
                matchSimilar: '@Localizer["MatchSimilar"].Value',
                matchDifferent: '@Localizer["MatchDifferent"].Value'
            };

            // Drag and drop
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadImage(file);
                }
            });

            // Click to upload
            uploadZone.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                imageInput.click();
            });

            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadImage(file);
                }
                imageInput.value = '';
            });

            // Remove image
            removeImageBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                resetToUpload();
            });

            // Zoom controls
            zoomInBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                setZoom(zoom * 1.5);
            });

            zoomOutBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                setZoom(zoom / 1.5);
            });

            zoomResetBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                zoom = 1;
                panX = 0;
                panY = 0;
                renderCanvas();
                updateZoomDisplay();
            });

            function setZoom(newZoom, centerX, centerY) {
                const oldZoom = zoom;
                zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

                // If center point provided, adjust pan to keep that point stationary
                if (centerX !== undefined && centerY !== undefined && currentImage) {
                    const canvasRect = canvas.getBoundingClientRect();
                    // Convert screen coordinates to image coordinates at old zoom
                    const imgX = (centerX / (baseScale * oldZoom)) + panX;
                    const imgY = (centerY / (baseScale * oldZoom)) + panY;
                    // Calculate new pan to keep this point under cursor
                    panX = imgX - (centerX / (baseScale * zoom));
                    panY = imgY - (centerY / (baseScale * zoom));
                }

                clampPan();
                renderCanvas();
                updateZoomDisplay();
            }

            function clampPan() {
                if (!currentImage) return;
                const viewW = canvas.width / (baseScale * zoom);
                const viewH = canvas.height / (baseScale * zoom);
                const maxPanX = Math.max(0, currentImage.width - viewW);
                const maxPanY = Math.max(0, currentImage.height - viewH);
                panX = Math.max(0, Math.min(maxPanX, panX));
                panY = Math.max(0, Math.min(maxPanY, panY));
            }

            function updateZoomDisplay() {
                zoomLevelDisplay.textContent = Math.round(zoom * 100) + '%';
                // Update cursor based on zoom level
                canvas.classList.toggle('can-pan', zoom > 1);
            }

            function loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        currentImage = img;
                        zoom = 1;
                        panX = 0;
                        panY = 0;
                        displayImage(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            function displayImage(img) {
                uploadZone.style.display = 'none';
                canvasContainer.style.display = 'block';
                resultsSection.style.display = 'none';
                matchesSection.style.display = 'none';

                const maxWidth = canvasWrapper.clientWidth || 800;
                const maxHeight = 600;

                baseScale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);

                canvas.width = img.width * baseScale;
                canvas.height = img.height * baseScale;

                renderCanvas();
                updateZoomDisplay();
            }

            function renderCanvas() {
                if (!currentImage) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();

                // Apply zoom and pan
                const scale = baseScale * zoom;
                ctx.scale(scale, scale);
                ctx.translate(-panX, -panY);

                // Draw the image at its natural size (transforms handle the rest)
                ctx.drawImage(currentImage, 0, 0);

                ctx.restore();

                // Hide sample indicator when view changes
                sampleIndicator.style.display = 'none';
            }

            function resetToUpload() {
                currentImage = null;
                zoom = 1;
                panX = 0;
                panY = 0;
                uploadZone.style.display = 'flex';
                canvasContainer.style.display = 'none';
                resultsSection.style.display = 'none';
                sampleIndicator.style.display = 'none';
                imageInput.value = '';
            }

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const delta = e.deltaY > 0 ? 0.8 : 1.25;
                setZoom(zoom * delta, x, y);
            }, { passive: false });

            // Mouse panning
            canvas.addEventListener('mousedown', (e) => {
                if (zoom > 1) {
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    canvas.classList.add('panning');
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (isPanning && currentImage) {
                    const dx = (e.clientX - lastPanX) / (baseScale * zoom);
                    const dy = (e.clientY - lastPanY) / (baseScale * zoom);
                    panX -= dx;
                    panY -= dy;
                    clampPan();
                    renderCanvas();
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                }
            });

            window.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    canvas.classList.remove('panning');
                }
            });

            // Touch handling for pinch-zoom and pan
            let touchStartTime = 0;
            let touchMoved = false;

            canvas.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                touchMoved = false;

                if (e.touches.length === 2) {
                    // Pinch start
                    lastPinchDist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                } else if (e.touches.length === 1 && zoom > 1) {
                    // Pan start
                    isPanning = true;
                    lastPanX = e.touches[0].clientX;
                    lastPanY = e.touches[0].clientY;
                }
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                touchMoved = true;

                if (e.touches.length === 2) {
                    e.preventDefault();
                    // Pinch zoom
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const rect = canvas.getBoundingClientRect();

                    if (lastPinchDist > 0) {
                        const scale = dist / lastPinchDist;
                        setZoom(zoom * scale, centerX - rect.left, centerY - rect.top);
                    }
                    lastPinchDist = dist;
                } else if (e.touches.length === 1 && isPanning) {
                    e.preventDefault();
                    // Pan
                    const dx = (e.touches[0].clientX - lastPanX) / (baseScale * zoom);
                    const dy = (e.touches[0].clientY - lastPanY) / (baseScale * zoom);
                    panX -= dx;
                    panY -= dy;
                    clampPan();
                    renderCanvas();
                    lastPanX = e.touches[0].clientX;
                    lastPanY = e.touches[0].clientY;
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                isPanning = false;
                lastPinchDist = 0;

                // Only sample color on quick tap without movement
                if (!touchMoved && e.changedTouches.length === 1 && Date.now() - touchStartTime < 300) {
                    const touch = e.changedTouches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    sampleColorAt(x, y);
                }
            });

            // Mouse click to sample (only if not panning)
            canvas.addEventListener('click', (e) => {
                if (!isPanning) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    sampleColorAt(x, y);
                }
            });

            function sampleColorAt(canvasX, canvasY) {
                if (!currentImage) return;

                // Convert canvas coordinates to image coordinates
                const imgX = (canvasX / (baseScale * zoom)) + panX;
                const imgY = (canvasY / (baseScale * zoom)) + panY;

                // Check bounds
                if (imgX < 0 || imgX >= currentImage.width || imgY < 0 || imgY >= currentImage.height) {
                    return;
                }

                // Show indicator at canvas position
                const wrapperRect = canvasWrapper.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                const canvasOffsetX = canvasRect.left - wrapperRect.left;
                const canvasOffsetY = canvasRect.top - wrapperRect.top;

                sampleIndicator.style.left = (canvasOffsetX + canvasX) + 'px';
                sampleIndicator.style.top = (canvasOffsetY + canvasY) + 'px';
                sampleIndicator.style.display = 'block';

                // Sample from original image (create temp canvas for accurate sampling)
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = currentImage.width;
                tempCanvas.height = currentImage.height;
                tempCtx.drawImage(currentImage, 0, 0);

                // Get 5x5 pixel average from original image
                const size = 5;
                const halfSize = Math.floor(size / 2);
                const startX = Math.max(0, Math.floor(imgX) - halfSize);
                const startY = Math.max(0, Math.floor(imgY) - halfSize);
                const endX = Math.min(currentImage.width, startX + size);
                const endY = Math.min(currentImage.height, startY + size);

                const imageData = tempCtx.getImageData(startX, startY, endX - startX, endY - startY);
                const pixels = imageData.data;

                let totalR = 0, totalG = 0, totalB = 0;
                const pixelCount = (endX - startX) * (endY - startY);

                for (let i = 0; i < pixels.length; i += 4) {
                    totalR += pixels[i];
                    totalG += pixels[i + 1];
                    totalB += pixels[i + 2];
                }

                const r = Math.round(totalR / pixelCount);
                const g = Math.round(totalG / pixelCount);
                const b = Math.round(totalB / pixelCount);

                displaySampledColor(r, g, b);
                findMatches(r, g, b);
            }

            function displaySampledColor(r, g, b) {
                const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();

                sampledSwatch.style.backgroundColor = hex;
                sampledHex.textContent = hex;
                sampledRgb.textContent = `RGB(${r}, ${g}, ${b})`;

                // Determine text color based on luminance
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                sampledSwatch.classList.toggle('dark-text', luminance > 0.5);

                resultsSection.style.display = 'block';
                loadingState.style.display = 'flex';
                matchesSection.style.display = 'none';
                canvasHint.textContent = strings.sampleAgain;
            }

            async function findMatches(r, g, b) {
                try {
                    const response = await fetch(`/api/ral/match?r=${r}&g=${g}&b=${b}&culture=${culture}`);
                    const data = await response.json();

                    loadingState.style.display = 'none';
                    matchesSection.style.display = 'block';

                    renderMatches(classicMatchesGrid, data.classic);
                    renderMatches(designMatchesGrid, data.design);
                } catch (error) {
                    console.error('Error finding matches:', error);
                    loadingState.style.display = 'none';
                }
            }

            function getDeltaELabel(deltaE) {
                if (deltaE < 1) return { text: strings.matchExact, class: 'exact' };
                if (deltaE < 2) return { text: strings.matchVeryClose, class: 'very-close' };
                if (deltaE < 5) return { text: strings.matchClose, class: 'close' };
                if (deltaE < 10) return { text: strings.matchSimilar, class: 'similar' };
                return { text: strings.matchDifferent, class: 'different' };
            }

            function renderMatches(container, matches) {
                container.innerHTML = matches.map((match) => {
                    const label = getDeltaELabel(match.deltaE);
                    const textClass = match.needsDarkText ? 'dark-text' : '';
                    const detailsUrl = `/${culture}/ral-colors/${match.slug}`;

                    return `
                        <a href="${detailsUrl}" class="match-card">
                            <span class="match-swatch ${textClass}" style="background-color: ${match.hex}"></span>
                            <span class="match-info">
                                <strong class="match-number">RAL ${match.number}</strong>
                                <span class="match-name">${match.name || ''}</span>
                            </span>
                            <span class="match-similarity ${label.class}">
                                <span class="similarity-label">${label.text}</span>
                                <span class="similarity-delta">ΔE ${match.deltaE}</span>
                            </span>
                        </a>
                    `;
                }).join('');
            }
        })();
    </script>
}
